package kthcharacter

import (
	"math/bits"
)

// Задача https://leetcode.com/problems/find-the-k-th-character-in-string-game-ii/?envType=daily-question&envId=2025-07-04
// Задача найти к-ый символ в строке, которая генерируется по следующему условию:
// Исходные данные: строка с символом 'a'
// массив операций
// Если operations[i] == 0, добавить копию word к себе.
// Если operations[i] == 1, сгенерируйте новую строку, заменив каждый символ wordна следующий символ в английском алфавите, и добавьте ее к исходной word.
// Например, выполнение операции над "c"generates "cd"и выполнение операции над "zb"generates "zbac".
// Используется английский алфавит в нижнем регистре ('a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n' 'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'y' 'z')
// Множесто является кольцом, тоесть после 'z' -> 'a'
//
// Требуется вернуть k-й символ строки после k генераций

// Пример:
// Ввод: k = 5, операции = [0,0,0]
// Вывод: "а"

// Объяснение:

// Первоначально word == "a"Алиса выполняет три операции следующим образом:

// Добавляется "a"к "a", wordстановится "aa".
// Добавляется "aa"к "aa", wordстановится "aaaa".
// Добавляется "aaaa"к "aaaa", wordстановится "aaaaaaaa".
// К-й символ в "aaaaaaaa" - это k-1 индекс, поэтому Результат: 'a'

// 1. Идея:
// Исходя из удвоений длины строки после каждой генерации, можно сделать log(k) генераций, чтобы получить нужный символ
// Как определить к-й элемент?
// 1. Пусть к = 10, значит строка из 16 символов
// 2. На предыдущей итерации мы дулируем строку по operations[i], если operations[i] == 0, то мы дублируем строку, если operations[i] == 1, то мы заменяем каждый символ на следующий символ в английском алфавите
// 3. 10-8 = 2.
// 4. Значит на 10-ю позицию символ после преобразования попал со 2-й позиции
// 5. для  2 подходит сторока из 2-х символов
// 6. на 2-ю позицию символ после преобразования попал со 1-й позиции
// На первой позиции всегда символ 'a'
// Значит на следующие позиции символ либо приращается, либо нет, и все зависит от того, чему равен operations[i]
// Надо из к вычесть предыдущий размер строки на operations[len(operations) - 2 - i] генерации
// делим к /2 смотрим остаток, смотрим operations[len(operations) - 1 - i], если остаток = 1 и operations[len(operations) - 1 - i] == 1 накапливаем счетчик, иначе -  нет

func kthCharacter(k int64, operations []int) byte {
	var charOffset int

	for k > 1 {
		power := bits.Len64(uint64(k)) - 1
		if (1 << power) == k {
			power--
		}
		k -= (1 << power)
		if operations[power] == 1 {
			charOffset++
		}
	}

	return 'a' + byte(charOffset%26)
}
